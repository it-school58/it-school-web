<h2>Классы</h2>

<ul class="list-point">
    <li><u-text-define>Класс</u-text-define> - функция/шаблон, предназначенный для создания объектов и методов</li>
    <li><u-text-define>Конструктор</u-text-define> - метод, который вызывается в момент создания объекта т.е. когда используется ключевое слово new он создает свойства и инициализирует, т.е. подготавливает объект к использованию</li>
	<li><u-text-define>this</u-text-define> - ссылка на текущий контекст вызова (на текущий объект с которым произошло событие)</li>
</ul>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Создание класса</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<v-code lang="js" title="">
// Создание класса
class User {
	constructor(name, age) {
		this.name = name;
		this.age = age;
	}
	authorizate() {
		console.log('Hello' + this.name);
	}
}

// Создание экземпляра класса (объекта)
const user = new User('Tony', 25); 
</v-code>

<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<h3>Наследование</h3>
<!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
<ul class="list-point">
    <li>Если у подкласса нет конструктора, он будет использовать конструктор родителя</li>
    <li>Если подклассу указать конструктор, то он должен вызывать в начале конструктор родительского класса <u-code-text>super()</u-code-text></li>
    <li>Метод <u-code-text>super()</u-code-text> позволяет наследовать свойства и методы из прототипа</li>
</ul>

<v-code lang="js" title="">
class User {
	constructor(name) {
		this.name = name;
	}
	getName() {
		console.log(this.name);
	}
}

class Admin <u-code>extends</u-code> User {
	constructor(name) {
		<u-code>super</u-code>(name);
	}
}

const admin = new Admin('Tony');
admin.getName();    // => "Tony"
console.log(admin); // => Object { name: "Tony" }
</v-code>
